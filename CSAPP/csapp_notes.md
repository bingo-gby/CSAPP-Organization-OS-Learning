# CSAPP概述
太多lab了，后面挑自己不是很理解的部分做做lab吧。

# 数据的表示
everything is bits，0 or 1。主要方便存储。一般二进制中的小数点含义类似于十进制：右边第一位代表2^-1,第二位代表2^-2。1字节=8 bits，通常4个比特位用一个16进制的0-F来表示。因此一个字节就是两个16进制数。可以进行训练，2进制和16进制之间的转换，记住几个主要的表示即可。
| 16进制| 2进制 |
| :------------ | :------------: |
| F     |  1111 | 
| A      | 1010 |
| C      | 1100 |  
位之间存在位运算（假设1为真，0为假）： &（and）、|（or）、not（~）Exclusive-Or（^,相同为0，不同为1，感觉只要记住 1 0为1，其他为0就行，不用关注相不相同，或者理解成相加）。
>位运算的用处：
>1. 表示集合；假如01101001，可以表示为{0，3，5，6}(这些位从右往左数起，位上为1，所以8位可以表示0-7的数)，这样节省空间。并且这种情况下：&类似于交集，|类似于并集，^类似于对称差异（两者不同时有的），~类似于补集。  
>2. 区分于逻辑运算： && || !，逻辑运算中，0为false，1为true。所以 !0x41 = 0x00。另外，如果想确保p是否为空指针可以用 `P && *P `,前面看是否是空指针，后面看是否指向有效值，另外逻辑运算存在 **短路效应**,例如 A||B，如果 A为真，就不会去评估B了，因为B无论是啥结果都是真。  
>3. 移位运算符：通常分为左移和右移，并且分为逻辑移动和算术移动。一般左移只有逻辑左移，就正常右端补0。右移分为逻辑右移和算术右移：逻辑右移同上，算术右移补的不一定是0，最高位是0就补0，最高位是1就补1。算术右移主要用于有符号整数。  
另外一个w位的数据类型移动 k>=w 位时，会取模 k=k%w，避免数据丢失。  

无符号整型的2进制转10进制比较简单，就是直接2的幂加权即可。有符号整数转换公式如下(**补码也等于源码取反+1)**：  
$$ B2T(x) = \sum_{i=0}^{w-2}x_i*2^i-{x_{w-1}*2^{w-1}} $$
>理解如下：后w-2位正常加权，然后减去第一位*2的幂（所以如果第一位是1就是负数，是0就是正数）。 如`10110 = -16+4+2 = -10 `  

计算机内通常采用补码表示数字，假如源码表示是 x ,那么取反+1就是
$$ 2^n-1-x+1 = 2^{n-1}-x $$
也就是实际补码表示的大小。所以有符号整型中最大值是2^(w-1)-1,最小值是-2^(w-1),正数表示的比负数少1（绝对值来看）特殊情况：所有位为1等于-1.
```
int number = -1;
int number1 = 7;
std::bitset<4> binaryRepresentation(number);
std::cout << binaryRepresentation << std::endl; // 1110
std::bitset<4> binaryRepresentation1(number1);
std::cout << binaryRepresentation1 << std::endl; // 0111
```
可以通过bitset容器打印出其二进制表示。


