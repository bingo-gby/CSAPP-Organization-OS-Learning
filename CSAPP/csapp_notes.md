# CSAPP概述
太多lab了，后面挑自己不是很理解的部分做做lab吧。

# 数据的表示

## 1. int 和 unsigned int
everything is bits，0 or 1。主要方便存储。一般二进制中的小数点含义类似于十进制：右边第一位代表2^-1,第二位代表2^-2。1字节=8 bits，通常4个比特位用一个16进制的0-F来表示。因此一个字节就是两个16进制数。可以进行训练，2进制和16进制之间的转换，记住几个主要的表示即可。
| 16进制| 2进制 |
| :------------ | :------------: |
| F     |  1111 | 
| A      | 1010 |
| C      | 1100 |  
位之间存在位运算（假设1为真，0为假）： &（and）、|（or）、not（~）Exclusive-Or（^,相同为0，不同为1，感觉只要记住 1 0为1，其他为0就行，不用关注相不相同，或者理解成相加）。
>位运算的用处：
>1. 表示集合；假如01101001，可以表示为{0，3，5，6}(这些位从右往左数起，位上为1，所以8位可以表示0-7的数)，这样节省空间。并且这种情况下：&类似于交集，|类似于并集，^类似于对称差异（两者不同时有的），~类似于补集。  
>2. 区分于逻辑运算： && || !，逻辑运算中，0为false，1为true。所以 !0x41 = 0x00。另外，如果想确保p是否为空指针可以用 `P && *P `,前面看是否是空指针，后面看是否指向有效值，另外逻辑运算存在 **短路效应**,例如 A||B，如果 A为真，就不会去评估B了，因为B无论是啥结果都是真。  
>3. 移位运算符：通常分为左移和右移，并且分为逻辑移动和算术移动。一般左移只有逻辑左移，就正常右端补0。右移分为逻辑右移和算术右移：逻辑右移同上，算术右移补的不一定是0，最高位是0就补0，最高位是1就补1。算术右移主要用于有符号整数。  
另外一个w位的数据类型移动 k>=w 位时，会取模 k=k%w，避免数据丢失。  

无符号整型的2进制转10进制比较简单，就是直接2的幂加权即可。有符号整数转换公式如下(**补码也等于源码取反+1)**：  
$$ B2T(x) = \sum_{i=0}^{w-2}x_i*2^i-{x_{w-1}*2^{w-1}} $$
>理解如下：后w-2位正常加权，然后减去第一位*2的幂（所以如果第一位是1就是负数，是0就是正数）。 如`10110 = -16+4+2 = -10 `  

计算机内通常采用补码表示数字，假如源码表示是 x ,那么取反+1就是
$$ 2^n-1-x+1 = 2^{n-1}-x $$
也就是实际补码表示的大小。所以有符号整型中最大值是2^(w-1)-1,最小值是-2^(w-1),正数表示的比负数少1（绝对值来看）特殊情况：所有位为1等于-1.
```
int number = -1;
int number1 = 7;
std::bitset<4> binaryRepresentation(number);
std::cout << binaryRepresentation << std::endl; // 1110
std::bitset<4> binaryRepresentation1(number1);
std::cout << binaryRepresentation1 << std::endl; // 0111
```
可以通过bitset容器打印出其二进制表示。
在一个不等式中，unsigned 和 signed比较，会自动进行类型转换，都转成unsigned进行比较，会**+/- 2^w（U2T or T2U）**。如果两个类型相同，那就不需要进行转换了。这里有个需要注意的地方：
```
// 这样会报错，因为unsigned会一直大于0，下面溢出后，会直接回绕成2^32 -1,然后就会访问未定义的内存，触发未定义行为
int main(){
    int a[5]={1,1,1,1,1};
    for( unsigned int i=4;i>=0;i--){
        cout<<a[i]<<endl;
    }
    return 0;
}

// 那如果将循环改成这个呢，同样报错，因为sizeof()返回unsigned，然后int也会转为unsigned。
for(int i=4;i-sizeof(char)>=0;i--)
```
实际使用中，还会用到signed Extension（例如一个8位的有符号整型要变成32位的有符号整型），如果是正数（前面补24位0即可），如果是负数就在前面补24位1即可。这可以解释一下算术右移前面补1的情况。证明如下（假设从m位扩充到n位）：
$$ X_{ago} = a - 2^{m-1}, X_{now} = X_{ago}+2^{m}+2^m*{(2^{n-m-1}-1)-2^{n-1} = X_{ago} }$$
那如果是 Truncating(截断，例5位变4位，unsigned类型)，直接取mod。例如 11011（27）变成 1011（11）直接 27%16=11。16为2的4次方（截断之后的位数）。如果是signed类型貌似没啥规律。  
数字的运算有加减乘除：
1. unsigned加时，溢出情况会直接丢弃溢出位（就是前面说的取模），signed相加也会有类似情况，例如 1101（-3）+0101（5） =0010（截断了，2），符合预期，如果溢出会导致 +2^w(负溢出) 或者-2^w(正溢出)，理解为回绕也ok。
2. 减法，可以转换为加法。**-5取反+1就得到5，5取反+1就得到-5，牢记！！！**。
3. 乘法:w位与w位相乘得到2w位，需要截断成w位，mod 2^w(unsigned),若为signed,先把x y 理解成无符号，然后mod 2^w,再unsigned 转 signed。例如 2（0010）*（-3）（1101）= 1010（10）然后U2T（-16）=-6。因为有符号相乘和无符号相乘最后保留的几位都是相同的。如果是乘以 2^w,就左移 w位。
4. 除法：除以2的幂，就右移，得到是商，正负都是向下取。例如0110（6）/4 =(0001)(1),补码1010（-6）/4 = 1110（-2）。都是向下取整，补码是算术右移，前面补1。但是负数向下取整(正常-6/4=-1)不符合人们直觉，所以一般会选择偏置，然后达到一体化（“向0舍入”）。偏置怎么偏，例如 -6/4 = (-6+3)/4 （这里向下取整） = -1，右移k位，就偏置(2^k -1),也就是 [x/y] = [(x+y-1)/y]。  

## 2. float 
浮点数的储存更为复杂，参考十进制的小数点，小数点后面1位就是 2^-1，依次类推。但是这样表示不是太精确，并且取值范围有限（浮点数就是说小数点在浮动）。最后引出了个标准化表示，类似于科学计数法。  
$$ (-1)^s *M*2^E$$ 
s为符号位，M为二进制小数，通常 1~2，后面E就是指数。通常有单精度（float，32位 1 8 23）和双精度（double，64位， 1 11 52），分别代表符号位 指数 小数（指数就是8位和11位，也叫做阶码）
1. 规格化，exp的位不为0，也不全为1.此时阶码的值为
   $$ E=e-Bias, bias = 2^{k-1}-1, k为阶码位数,e为表示的unsigned $$
   所以单精度就是 -126~127 双精度就是 -1022~1023；加偏置的原因是方便比大小。尾数就直接表示0~1的小数（代表小数点右边所有数字），然后默认+1，就能表示1~2了。
2. 非规格化：exp全为0。
    $$ E = 1 - bias $$
    尾数M = f，不包含隐藏的1。这是为了方便表示那些接近0的数。此时 E = -126（单精度），尾数就是实际数字。
3. 特殊值:exp全为1，f =0000..，代表无穷大，根据前面符号确定是正无穷还是负无穷；如果 f不全为0，代表NaN。
4. 这里举例 符号位1位，exp 4位，小数 3位。那么最小的规格化数（以正数为例）是 00001000，就是 1*2^-6 = 8/512。最大的非规格化数是 0000111，是 7/8 * 2^-6 = 7/512。 这样就让数字平稳过渡了。这也解释了**为什么非规格数要写成 1-bias，M = f**。
5. 由于表示方法限制了浮点数范围和精度，所以需要舍入来找近似值表达。但是浮点数需要计算，如果舍入不合理，舍入误差会不断积累，造成较大误差，所以采用**四舍六入五偶（减小误差）**，补充一下十进制小数转2进制采用 乘2取整法。
6. 浮点数乘法：s=s1^s2（异或），M= M1*M2， E=E1+E2。 M需要移位到1~2，E溢出就直接变为无穷。浮点数加法对齐到指数高的那一个，然后通过移位确定小数。如 1.01 * 2^10 + 2.01 * 2^17， 需要对齐到 17，然后1.01 转为2进制再移位。 ps： 如果一个很小的浮点数加减一个很大的浮点数，有可能小数直接就被略掉了，因为在很后面，然后截断。例如 3.14+1e10-1e10=0，3.14+(1e10-1e10)=3.14，所以在进行浮点数之间相加减和相乘除时需要注意结合。
7. int float 和 double之间的转换：int转float，可能会被舍入。int float转double比较精确，float和double转int可能会溢出，会直接把小数截断,例 (int)(1.8)=1。

## 3. bytes order
补充一下，字节在内存中以什么样的顺序存储：小端序（为主，低地址存低字节）和大端序（网络传输多用）。例如 0x1234,0x34是低字节就存在低位，大端序跟人眼看到的一样，0x1234,0x12为低地址。测试如下：
```
// 可以判断是大端序还是小端序，让num=1，看输出是否01,是就是小端序，反之就是大端序。
typedef unsigned char * byte_pointer;  // 用指针数组
void show_bytes(byte_pointer start, size_t len){
    size_t i;
    for(i = 0; i < len; i++){
        printf("%.2x\n", start[i]);
    }
    printf("\n");
}
int main(){
    int number = 15213;
    show_bytes((byte_pointer) &number, sizeof(int)); // 6d 3b 00 00
    return 0;
}
// 计算 15123 = 3* 16^3 + 11*16^2 + 6*16 +13, 所以表示应该是 3b6d,所以是小端序。
```
# 程序的机器表示

