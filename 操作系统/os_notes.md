# 操作系统
操作系统是给计算机硬件（CPU、内存）穿上了衣服，抽象了一层，管理硬件，例如CPU、内存、磁盘、文件、终端等。计算机五大部件：I/O设备 存储器 运算器 和控制器。计算机就是在不断地 “取指执行”，但是要把操作系统从磁盘上载入内存里，才能取指。 
那么打开电源，计算机执行的第一条指令是什么？  
>1. 刚开机，cpu处于**实模式**。CS 寄存器（16位寄存器）（存储当前代码段的基地址）的值乘以16（即左移4位）给出了当前执行的指令的物理内存地址。换句话说，CS 寄存器的值经过位移操作后，会与指令指针（IP/PC）组合，形成完整的内存地址，用于取下一条指令。  
>2. 例如 开机时CS=0xFFFF，IP=0x0000，然后寻址0xFFFF0（内存BIOS映射区）然后自检，接着将磁盘0磁道0扇区（操作系统的引导扇区，一个扇区512字节）读入0x7c00,设置 CS = 0x07c0，IP = 0x0000（说明之后要跳到操作系统来执行了）。  
>3. 引导扇区代码是汇编代码，bootsect.s(读入系统)，然后再执行setup.s（完成OS启动前的设置）,举例：
```
// 将操作系统移到0地址去
// 段寄存器（如DS和ES）与偏移量（如SI和DI）所以是把 ds：si（一个地址）（0x10000） 移到 es：di（一个地址）（0x0000）（ds是数据段寄存器，es是附加段寄存器）
// 段寄存器<<4 + 偏移量 为当前访问地址
    move ax,#0x0000
do_move:
    mov es,ax add ax,0x1000
    cmp ax,#0x9000
    mov ds,ax sub di,di
    sub si,si
    mov cx, 0x8000
    rep movsw
    jmp do_move
```
然后先初始化GDT，然后```mov ax,#0x0001 mov cr0,ax```,导致cr0寄存器最后一位（PE）为1（为1启动保护模式），cpu进入保护模式，然后 ```jmpi,0,8```(将CS设为8，IP设为0)，指向的还是地址0x00。
>为什么存在实模式和保护模式?  
>因为实模式下，寻址空间只是20位（CS寄存器为16位），约1MB，所以要进入保护模式，更换寻址模式。还是通过CS 和 IP来寻址，但是CS中有个选择子（索引），通过GDT（全局描述符表）来取段描述符（有段基址和段界限），之后段地址就是 段描述符基地址+偏移量。如果有分页模式，继续找到页目录索引和页索引，然后页表包含物理帧号和页内偏移量。物理地址=页表帧号*页表大小+页内偏移量。补充一下：保护模式下中断函数 int n，也是去查表IDT，跳向中断处理函数接口，之前直接是单一的中断向量表。

然后再进入system模块，执行head.s,重新初始化IDT GDT,设置页表，然后调用main函数，进行一系列初始化，如内存初始化，main是一个永远不会退出的函数。
> 内存初始化了一个 mem_map的表格，前面used，后面都置为0。  
> <img src="photos/init.png" width="75%">  


## 1. 操作系统接口

