<!-- TOC -->

- [操作系统](#操作系统)
- [1. 操作系统概论](#1-操作系统概论)
  - [1. 操作系统开机](#1-操作系统开机)
  - [2. 操作系统接口](#2-操作系统接口)
  - [3. 系统调用实现](#3-系统调用实现)
  - [4. 学习目标](#4-学习目标)
- [2. cpu管理](#2-cpu管理)
  - [1. 多进程图像](#1-多进程图像)
    - [1. 多进程如何交替](#1-多进程如何交替)
    - [2. 多进程如何影响](#2-多进程如何影响)
    - [3. 多进程如何合作](#3-多进程如何合作)
    - [4. 总结](#4-总结)
  - [2. 线程](#2-线程)
    - [1. 用户级线程](#1-用户级线程)
    - [2. 内核级线程](#2-内核级线程)
    - [3. CPU调度策略和实际的schedule函数](#3-cpu调度策略和实际的schedule函数)
    - [4. 进程同步与信号量](#4-进程同步与信号量)

<!-- /TOC -->

# 操作系统
[OS参考笔记](https://blog.csdn.net/qq_53111905/article/details/119737978)
# 1. 操作系统概论

## 1. 操作系统开机
操作系统是给计算机硬件（CPU、内存）穿上了衣服，抽象了一层，管理硬件，例如CPU、内存、磁盘、文件、终端等。计算机五大部件：I/O设备 存储器 运算器 和控制器。计算机就是在不断地 “取指执行”，但是要把操作系统从磁盘上载入内存里，才能取指。 
那么打开电源，计算机执行的第一条指令是什么？  
>1. 刚开机，cpu处于**实模式**。CS 寄存器（16位寄存器）（存储当前代码段的基地址）的值乘以16（即左移4位）给出了当前执行的指令的物理内存地址。换句话说，CS 寄存器的值经过位移操作后，会与指令指针（IP/PC）组合，形成完整的内存地址，用于取下一条指令。  
>2. 例如 开机时CS=0xFFFF，IP=0x0000，然后寻址0xFFFF0（内存BIOS映射区）然后自检，接着将磁盘0磁道0扇区（操作系统的引导扇区，一个扇区512字节）读入0x7c00,设置 CS = 0x07c0，IP = 0x0000（说明之后要跳到操作系统来执行了）。  
>3. 引导扇区代码是汇编代码，bootsect.s(读入系统)，然后再执行setup.s（完成OS启动前的设置）,举例：
```
// 将操作系统移到0地址去
// 段寄存器（如DS和ES）与偏移量（如SI和DI）所以是把 ds：si（一个地址）（0x10000） 移到 es：di（一个地址）（0x0000）（ds是数据段寄存器，es是附加段寄存器）
// 段寄存器<<4 + 偏移量 为当前访问地址
    move ax,#0x0000
do_move:
    mov es,ax add ax,0x1000
    cmp ax,#0x9000
    mov ds,ax sub di,di
    sub si,si
    mov cx, 0x8000
    rep movsw
    jmp do_move
```
然后先初始化GDT，然后```mov ax,#0x0001 mov cr0,ax```,导致cr0寄存器最后一位（PE）为1（为1启动保护模式），cpu进入保护模式，然后 ```jmpi,0,8```(将CS设为8，IP设为0)，指向的还是地址0x00。
>为什么存在实模式和保护模式?  
>因为实模式下，寻址空间只是20位（CS寄存器为16位），约1MB，所以要进入保护模式，更换寻址模式。还是通过CS 和 IP来寻址，但是CS中有个选择子（索引），通过GDT（全局描述符表）来取段描述符（有段基址和段界限），之后段地址就是 段描述符基地址+偏移量。如果有分页模式，继续找到页目录索引和页索引，然后页表包含物理帧号和页内偏移量。物理地址=页表帧号*页表大小+页内偏移量。补充一下：保护模式下中断函数 int n，也是去查表IDT，跳向中断处理函数接口，之前直接是单一的中断向量表。

然后再进入system模块，执行head.s,重新初始化IDT GDT,设置页表，然后调用main函数，进行一系列初始化，如内存初始化，main是一个永远不会退出的函数。
> 内存初始化了一个 mem_map的表格，前面used，后面都置为0。  
> <img src="photos/init.png" width="75%">  


## 2. 操作系统接口
操作系统接口就是操作系统提供的一些重要函数，也可以叫做系统调用。一般接口形式有两种：命令行和图形化界面。命令行通过shell（在system模块 的main函数的最后启动的），观察这个main函数，意思如下：
>父进程调用fork()创建一个子进程。  
只有子进程会进入if语句的代码块中。  
在子进程中调用exec(cmd)，这将用cmd指定的命令替换当前（子）进程的执行上下文。  
  <img src="photos/命令行.png" width="75%">
    
图形化按钮就是：消息框架程序+消息处理程序。

<img src="photos/总结.png" width="75%">

并且这些重要的函数有个标准（程序换个操作系统也能用）。

<img src="photos/posix.png" width="75%">

## 3. 系统调用实现
直观想法：为什么不能访问内核？反正都是内存中。答：如果应用程序能访问内核，那么root密码或者其他软件的内容都一览无余（如word内容）...  
内核有 用户态 和 内核态。 系统调用就是提供进入内核的手段。

<img src="photos/内核.png" width="75%">

CS:IP指令（PC内的）的**最低两位**表示当前执行在哪个态（0为内核态，3为用户态）只有当 DPL（指令特权级）> CPL（当前特权级）才可以执行指令，**数字越大，特权级越低**。  
但是用户程序也提供唯一调用内核代码的方式：中断（int），int把 CS中的CPL改为0，就直接进入内核态了。系统调用的实现通过 int 0x80，例如prinf 使用了 write，write 系统调用中 包含int指令的代码。  
具体研究一下write 和 int 0x80。 

<img src="photos/systemcall1.png" width="75%">
<img src="photos/systemcall.png" width="75%">

标红的内嵌汇编意为把 _NR_write（一个宏 4，称为系统调用号） （这里name用write替代了）赋给 eax。同时eax也存放返回值，ebx，ecx，edx存放3个参数。这个宏函数名： syscall3中的3就代表3个参数。然后就开始根据系统调用号（4）执行相对于代码。 
int 0x80具体干了什么？

<img src="photos/80.png" width="75%">

set_system_gate来设置0x80的中断处理，同时把dpl赋为3。system_call为中断处理程序。所以总体流程是先把 dpl设置为3，让代码能够进入内核，进入内核之后，一系列操作把 cpl设为 0，然后就可以进行一系列操作了。`sys_call_table + 4* %eax` 代表相应系统调用处理函数（4代表每个系统调用占4个字节:32位下每个指针占4个字节），sys_call_table 就是个函数表。总体流程如下：

<img src="photos/sys_table.png" width="75%">
<img src="photos/sys.png" width="75%">

sys_write是系统调用函数,现在还没必要深入了解...

## 4. 学习目标

<img src="photos/goal.png" width="75%">

# 2. cpu管理
通过多进程管理好了cpu。cpu工作就是**不断自动取址执行（取PC里面的地址）**，所以设好PC初值就可以，就会按顺序执行指令...但是存在问题：
```
// fprintf（I/O指令）运行时间太长，会让CPU空等...
int main(int argc, char* argv[])
{
	int i , to, *fp, sum = 0;
	to = atoi(argv[1]);
	for(i=1; i<=to; i++)
	{
		sum = sum + i;
		fprintf(fp,“%d”, sum);
	}
}
```
所以实际cpu运行是这样：等的时候就去干其他事情，多个程序交替执行（并发）。

<img src="photos/cpu.png" width="75%">

怎么做到并发？ （1）切换PC（2）切换的时候记录返回地址 （3）保存切换前的上下文（如寄存器的信息）。所以每个程序有个存放信息的结构：PCB(process control block,进程控制块)。因此有进程（进行中的程序），**进程走走停停，需要PCB**(类似于备忘录)。

## 1. 多进程图像
多进程图像就是多个进程向前跑的样子，就是管理cpu的核心样子。开机时候：main里面的`if(!fork()){init();}` 创建了第一个进程，init()函数里面启动了shell，shell代码如下，shell根据cmd启动其他进程...（windows是启动桌面 ）  
<img src="photos/命令行.png" width="75%">  
多进程如何组织，有队列，且状态模型如下：  
<img src="photos/5tai.png" width="75%">  
运行态到堵塞态理解为饭卡找不着了（等待某事件），堵塞到就绪就是饭卡找到了（等待事情发生），然后重新排队，阿姨叫到你了（OS调度），打饭，打完重新打，需要重新排队（就绪态）。 ps：进程是由内核控制的。 

### 1. 多进程如何交替
切换就是 schedule 函数。但是进程调度太复杂，基本的就是FIFO（先进先出），但是没有考虑进程任务的优先级区别。我们看switch_to的代码：
```
// 就是把旧的cpu状态 保存在当前pCur（PCB）中，让 CPU去执行新的PCB(pNew)
switch_to(pCur,pNew){
  pCur.ax = CPU.ax;
  pCur.bx = CPU.bx;
  ...
  pCur.cs = CPU.cs;
  pCur.retpc = CPU.pc; //old

  CPU.ax = pNew.ax;  //new
  CPU.bx = pNew.bx;
  ...
  CPU.cs = pNew.cs;
  CPU.retpc = pNew.pc; 
}
```
### 2. 多进程如何影响
多进程都是放在内存中，就会出现问题（进程之间会互相更改信息），所以不同进程之间应该地址隔离。  
<img src="photos/table.png" width="75%">  
**通过进程映射表**，比如进程1和进程2中的地址100对应的是地址实际的780 和 1260，这样就隔离了。

### 3. 多进程如何合作
假如多个进程通常往一个内存位置write，就会乱套，**所以需要加锁**。如生产者消费者实例，核心在于进程同步。

### 4. 总结
多进程图像要有（1）读写PCB（2）操作寄存器保存上下文（3）写调度程序（4）进程同步（5）地址映射（地址隔离）。

## 2. 线程
### 1. 用户级线程
因为进程切换代价太大了（要切换映射表以及保存上下文信息），所以引出线程（共用映射表），保留并发特点，实际上就是资源不变，只切换执行指令（PC指针）。考虑一下多线程是否实用，举例说明：
> 其实可以这样理解：解耦成 多个指令交替执行 + 是否共用映射表，进程和线程的共同点是多个指令交替执行  
>例如浏览器有多个线程，一个线程用来显示文字，一个线程用来显示图片,一个线程用来下载... 这些线程共享资源。  

浏览器主干实现代码如下： 
```
void WebExplorer() { 
	char URL[] = “http://cms.hit.edu.cn”;
	char buffer[1000];   // 共用数据缓存区
	pthread_create(..., GetData, URL, buffer); //GetData
	pthread_create(..., Show, buffer); //Show
}
void GetData(char *URL, char *p){...};
void Show(char *p){...};
```
但是上述代码还没有实现 **指令交替执行** 的效果，因此在GetData和Show函数之内，有一个关键函数`Yield`,Yeild实现切换线程，是线程调度操作，它允许当前线程放弃对CPU的使用，即使它仍有时间片剩余。执行 yield 的线程将回到就绪队列。看看create 和 Yield的具体实现。

<img src="photos/yield.png" width="75%">  

两个线程应当有两个栈，如图所示。所以就需要有TCB，存栈指针。TCB和栈相互配合，考虑一下 jmp 204为什么去掉，试着模拟一下过程。
> 假如有 jmp 204，那么直接跳到204,执行完之后，然后ret（出栈204），会发现又执行204，这就会出问题。假如把 jmp 204去掉， yield函数返回，那么就会出栈（204），然后执行204。然后函数继续返回，出栈104，执行104。

所以，yeild的任务就是 切换栈，**不需要jmp** ！  
create就是要把yield使用到的东西都创建出来：（1）TCB （2）栈（3）TCB和栈关联起来
```
void ThreadCreate(A)
{
	TCB *tcb=malloc();
	*stack=malloc();
	*stack = A;//100
	tcb.esp=stack;   // 关联TCB和栈
}
```
上述是用户级线程（由用户手动切换），Yield是用户程序。但是存在问题，假如用户级线程进入内核堵塞（这里举例，网不好，就会去内核调用网卡IO，但是现在程序仍处于用户态），OS就会切换进程（因为不知道TCB），而不是切换线程，这样线程的并发性就丧失了。核心级线程是系统调用，会进入内核，内核管理PCB，负责切换线程。
### 2. 内核级线程
进程都是内核态，没有用户级进程这一说法，因为进程需要的资源都是计算机来分配，都是在内核态。补充个概念：多cpu和多核，多cpu就如字面意思，多核就是多个处理核心共享同一资源，而多cpu中的每个cpu都有自己独立的缓存。  
现在核心级线程有一套栈（一个用户栈和一个内核栈），之前是根据TCB来切换用户栈，现在TCB切换，用户栈和内核栈都要切，就是切一套栈。但是TCB是关联内核栈，用户栈怎么切？

<img src="photos/s.png" width="75%">  
<img src="photos/yitao.png" width="75%"> 

用户栈跟内核栈的关联如上：用户栈切换到内核栈通过中断，然后将 栈的始尾指针保存过去，和指令地址（PC CS），然后IRET（中断返回）返回的时候，就弹栈找到之前用户栈在的位置。然后内核栈之间切换用switch_to函数。一般线程大部分都是工作在用户态，只是用到内核的时候，去内核溜达一圈，然后直接通过CS:PC 返回用户态程序。所以有两套栈的切换。（包含内核栈和用户栈）。switch_to 的五段论：

<img src="photos/switch.png" width="75%"> 

同样切换知道了，那么创建一样需要创建：（1）用户栈（2）内核栈（3）TCB（4）TCB跟内核栈的关联。  
内核级线程实现如下：

<img src="photos/fork.png" width="75%"> 

OS就是一颗树，CPU就是种子，不断取址执行。然后并行处理（CPU好好运转，指令跳转），是对前面的总结，思维循循渐进。举例说明：从一个简单、清晰、明确的目标开始 交替的打出A和B (Linux 0.01)  
从用户代码开始：比较复杂，自己去做lab就知道了..
```
main()
{
	if(!fork()){while(1)printf(“A”);}
	if(!fork()){while(1)printf(“B”);}  // 时钟中断切换 A 和 B
	wait(); // 将父进程变成堵塞态，然后调用schedule函数，schedule是调度，选择合适的进程，然后switch_to 切换
}
```
### 3. CPU调度策略和实际的schedule函数
cpu调度就是 选择 next process。schedule函数。常见的策略：
1. FIFO，先进先出，但是如果只是简单询问业务的人？
2. 考虑Priority，任务短可以适当优先。
3. 让进程满意：（1）尽快结束任务（2）尽快响应用户操作（3）系统内耗时间少（尽可能让系统一直在工作），但是通常存在折中，前台性任务要求响应时间，后台性任务要求周转时间（尽快完成任务）。所以针对不同的要求，有不同的策略...  

实际的基本CPU调度算法示例：
1. SJF: 短作业优先，导致周转时间最小，用小顶堆来实现。
2. 时间片调度：改善响应时间，一个个给一点点时间片，用完就下一个。
3. 周转时间和响应时间都要求：例如word关心响应时间，gcc关心周转时间，直观想法：前台任务 和后台任务队列，前台任务采用时间片调度，后台采用SJF，前台任务队列没了才去调度后台任务队列。这样会存在问题：后台任务容易陷入饥饿状态。解决方法：采用动态优先级，前台任务和后台任务优先级动态变化...(后台任务以SJF为核心，但是也要加时间片，这样执行久的话就可以跳转前台任务)

一个实际的schedule函数如下：
```
/* this is the scheduler proper: */
while (1) {
  c = -1;  
  next = 0;
  i = NR_TASKS;   // num_Tasks
  p = &task[NR_TASKS]; // p队列地址
  while (--i) {
    if (!*--p)
      continue;
    // 如果状态是就绪（TASK_RUNNING）且 counter > c
    if ((*p)->state == TASK_RUNNING && (*p)->counter > c)  
      c = (*p)->counter, next = i;
  }

  if (c) break;   // 找到了最大的counter所在的Task,直接跳出
  
  // 如果所有就绪态的counter都为0，时间片都用完了。当然要考虑那些堵塞态的，堵塞态此时counter不为0
  for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
  { 
    if (*p)
    {
      (*p)->counter = ((*p)->counter >> 1) + (*p)->priority;  // 如果是就绪态 counter就是 priority，堵塞态的就要大于 priority，导致堵塞态优先级高点
    }
  }
}
switch_to(next);
```
上面的代码保证堵塞态变为就绪态的进程优先级要高于那些直接是就绪态的进程，且I/O时间越长的，counter越久，所以这里counter的作用既有时间片作用又有优先级作用...counter作用总结：
1. counter保证了响应时间的界，就是 p+p/2 + p/4 ... = p(1-(1/2)^n)/0.5 < 2p (p为counter初值)
2. 经过IO以后，counter就会变大；IO时间越长，counter越大(为什么? 被阻塞的多了)，照顾了 IO进程，变相的照顾了前台进程
3. 后台进程一直按照counter轮转，**近似了**SJF调度 (短作业的先轮转完)
4. 每个进程只用维护一个counter变量，简单、高效

### 4. 进程同步与信号量